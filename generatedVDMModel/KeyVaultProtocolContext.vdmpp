class KeyVaultProtocolContext
types
-- TODO Define types here
values

allowedMessageOrder : map Message`MessageType  to set of Message`MessageType = {
	<UNKNOWN> |-> {<KEY_VAULT_DISCOVERY_REPLY>},
	<KEY_VAULT_DISCOVERY_REPLY> |-> {<KEY_VAULT_DISCOVERY_REPLY>, <CHALLENGE_SUBMISSION>},
	<CHALLENGE_SUBMISSION> |-> {<CHALLENGE_SUBMISSION> , <KEY_VAULT_CERTIFICATE>},
	<KEY_VAULT_CERTIFICATE> |-> {<KEY_VAULT_CERTIFICATE>, <CHALLENGE_ANSWER>},
	<CHALLENGE_ANSWER> |-> {<CHALLENGE_ANSWER>, <SIGNING_REPLY>},
	<SIGNING_REPLY> |-> {<SIGNING_REPLY>, <RE_KEY_REQUEST>},
	<RE_KEY_REQUEST> |-> {<RE_KEY_REQUEST>, <SIGNING_REPLY>}
};

instance variables
	javaObject: generated_vdm_VDMKeyVaultProtocolContext := new generated_vdm_VDMKeyVaultProtocolContext();
	private previousMessage : Message`MessageType := <UNKNOWN>;
operations
public setJavaObject: (seq of char) ==> ()
setJavaObject(vdmObjectName) == javaObject.setJavaObject(vdmObjectName);

public GENERATED_GenerateChallenge:() ==> (seq of int)
GENERATED_GenerateChallenge() == (
	--Extra VDM expressions can be added to this operation
	javaObject.GenerateChallenge();
);

public GENERATED_SendMessage:(seq of char) * (seq of char) ==> ()
GENERATED_SendMessage(type,contents) == (
	previousMessage := Message`StringToMessageType(type);
	return javaObject.SendMessage(type,contents);
)pre (
	    let messageType : Message`MessageType = Message`StringToMessageType(type) in (
	        messageType in set dom allowedMessageOrder and
          	messageType in set allowedMessageOrder(previousMessage)));

functions
-- TODO Define functions here
traces
-- TODO Define Combinatorial Test Traces here
end KeyVaultProtocolContext